You will need:

- A supportable Gimlet, or an Ethanol-X (for now)
- Milan, possibly; I believe this should also work on Rome but have not tried
  it yet
- illumos-gate stlouis a368956d97835cacf0266ab9ff2fe7b7944afa09 or later
- nanobl-rs 0.4.7 or later (0.4.1 and later will work but will require manual
  mapping of the space for the ramdisk prior to receiving it; the ramdisk
  exceeds the automap limit of 64 MiB in loaders older than 0.4.7)
- The tools in this directory

Steps:

1. Build the kernel, modules, and kmdb and its dependencies.  The kmdb deps
are a pain if you haven't set up a bunch of ancillary crap to build userland
(in particular, Python.h seems to come up a lot).  If you have nightly(1onbld)
working, that should work fine for building all the modules you need.  If you
want to build on an arbitrary build machine using adjuncts, consider applying
illumos-build-fixes.diff from this directory.

2. Build a ramdisk.  The size in mkrd.bash must match the end address property
value in usr/src/uts/oxide/os/boot_data.c; if you need to grow the ramdisk,
change both of these!  This program outputs the name of the ramdisk image; it
uses a temporary name because even though these are internal build machines
and basically single-user we try to avoid glaring security holes; if you want
to use a fixed name you can do something like:

	$ mv $(./mkrd.bash) /path/to/ramdisk.ufs

3. Build nanobl-rs and burn it to your test machine's boot flash.  See the
instructions in that repo's README.

4. At this point you should have:
	- A box sitting at the > prompt in your terminal emulator (see
	  nanobl-rs repo for notes on configuring it)
	- A copy of unix from $ROOT/platform/kernel/oxide/amd64/unix
	- A copy of ramdisk.ufs or whatever you called it

Note that we currently need unix in the ramdisk and outside it; this
requirement can eventually be relaxed because we actually have the ELF image
in memory and the loader could tell krtld where to find it to look up symbols.
That will save about 2 MiB in the image, but for now you need it twice, and
the file in the ramdisk MUST MATCH the kernel you boot; otherwise krtld will
complain and you will not get very far.

5. If you are using a rev A Gimlet and want a NIC and/or SSD(s), you must now
power on any sharkfin power controllers you need, then release PERST# for each
PCIe end device you wish to use.  Releasing PERST# requires hardware
modification; ask if you don't know what to do.  These steps may be done in
parallel with ramdisk loading (next step).

6. Now issue the following sequence of loader commands:

	> 101000000::recv -m

	Send the ramdisk you built previously via your terminal emulator's
Xmodem upload command at this time.  This command places the ramdisk into
memory at 1_0100_0000, which must match the address in oxide/os/boot_data.c.
Note that if you build a ramdisk larger than 64 MiB, you will also need to map
memory manually or specify the size in bytes on the loader command line.  See
the help for ::recv's -m option.

	> 100000000::recv -m | ::load | ::call

	Send unix in the same manner at this time.  You are free to put this
almost anywhere that the loader will let you, except for the area the ramdisk
already occupies and the regions the kernel itself wants to be loaded into.
The suggested address is convenient and out of the way and should work on
every supportable Gimlet and Ethanol-X.  When the file receiption completes,
::load and ::call will interpret the kernel and an ELF object and transfer
control to its entry point, booting the OS.  NOTE: This syntax is available
only in nanobl-rs 0.4.1 and later.  If you have 0.4.0, you can still boot but
will need to issue three separate commands instead of a single pipeline.

6. If you wish to proceed to userland, utter ':c' when kmdb loads, ignoring
any errors about failure to load kmods.  Otherwise, begin your debug session.

7. Upon reaching userland, if you have a NIC you can plumb up your network
links and routes, then utter '/root/start-sshd' to gain remote access.  The
collection of available phase-1 system software is very limited and heavily
skewed toward debugging tools.  If you want a more functional (RFD 241
"phase-2") system, build yourself a tarball from your proto area by doing
something like:

	$ cd $ROOT; tar cf phase2.tar kernel/drv kernel/fs kernel/misc \
	  usr/lib/devfsadm usr/bin usr/lib/lib* usr/lib/amd64/lib* usr/sbin \
	  kernel/strmod sbin/zpool sbin/zfs usr/xpg6/bin usr/lib/cfgadm \
	  lib/lib* lib/amd64/lib* lib/64 usr/lib/64 usr/lib/security
	$ scp phase2.tar root@gimlet:/tmp
	gimlet:~# cd /tmp && tar xpf phase2.tar
	gimlet:~# /root/post-phase2

The root user's environment is set up so that the stuff in /tmp/bin and so
forth will be on the PATH and libraries can generally be found.  You can of
course add or change the contents to suit your needs; the above will be enough
to give you working zpool and zfs commands so if you have storage you can now
create or import a pool, making it convenient to persist data across reboots
for debugging or V&V, store larger toolsets, etc.  All of this is definitely
not complete or perfect and some things probably still won't work; you are at
the end of the graded road so grab your illumos man pages and work it out for
yourself.

8. If you wish to re-enter kmdb, send a BREAK using your terminal emulator
(picocom default: C-a C-|).  There is currently no way to reboot.  On Gimlet,
use humility to cycle through A2.  On Eth-X, ipmitool or the web UI may be
used.

Next steps:

There are many, many things to do next, and the good news is that there is
enough parallelism here for 8-10 engineers.  A few examples:

- Unmap the loader's text, data, and miscellany.  At present, we know where
  the pagetables and earlyboot stack are, and the loader has set bit 11 in all
PTEs for the kernel, so we should be able to delete these mappings if we wish.
Regardless, they end up getting unmapped and the underlying pages freed later
in boot.

- Figure out how to turn off the three reserved regions of RAM the PSP wants.

- Set the magic undocumented MSRs for the BSP, and add code to MP startup to
  do it on APs once we get there.  This probably belongs in apix, which is a
much bigger can of worms.

- Fix up the boot time properties code so we can accept the root pointer as a
  physical address, or decide that we don't ever want the loader passing boot
properties and just have it pass the ramdisk location.  There are several ways
to do this and we should take a little time to think it through -- in
particular, how offsets/pointers internally to the properties are represented.
Doing 1275 is an option here though a read through that standard suggests far
more complexity than we want or need.

- Replace boot_data.c with RPC calls to the SP.

- We can remove more of the bootaux code if we want.  The kernel's ELF object
  is in memory, and we could have the loader tell us where it is if we wanted
to.  If we were clever we could even dispense with copying the contents and
just load it in the right place, then create the proper mappings.  You know,
like a loader.  See the notes above on step 4.

- Switch us to a compressed CPIO ramdisk.  We're certain to need it to save
  space, and probably time.  Even with just gzip, the existing 13 MiB ramdisk
that is very nearly enough to get to userland fits in about 4 MiB compressed,
which is shockingly comparable to LinuxBoot, though it doesn't include any
actual user programs.  This also offers us another path to simplify booting
into a single step, by including the kernel and having the loader extract it
from the archive instead of making them separate steps; we wouldn't want to
make the loader understand UFS but CPIO might be ok.

- Probably rewrite mlsetup(), which is needlessly complicated for our needs.

- Commonise the rest of the microcode updating code.  Being able to upgrade
  microcode will be one of the very first things we want to do, so we don't
chase ghosts once we have single-user up.

- Commonise (most?  all?) the x86 HAT code.  This is current machine arch
  specific but most of it is really not.  This is in fact the same thing they
found with SPARC when they created the sfmmu directory.

- Audit and remove all the -Nmisc/acpica and other -Ndrv/acpidrv etc.
  arguments.  This should be quick and simple, but removing the code that
actually consumes these interfaces won't be.  In most cases that code needs to
be rewritten entirely but that needs to be audited on a case by case basis;
there are likely to be places where we want to share most code that currently
consumes ACPI and it may be good to create a set of ops vectors or whatever
that allow generic consumers to use ACPI or go direct (similar to platmod/PSM,
probably, or we may even be able to just extend that interface to cover
multiple machine architectures).

- Delete the rebooting code, which doesn't work anyway.  Negotiate a
  communication mechanism with the SP that can be used to request a reset from
both earlyboot and a normal working system (i.e., this can't rely solely on
STREAMS or something like that).  Stuff like `pc_reset` needs to move to
i86pc.
